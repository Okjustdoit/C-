成员函数
    定义成员函数时，使用作用域解析运算符（::）来标识函数所属的类；
    void Stock::update(double price)//定义的update()函数是Stock类的成员
    类方法可以访问类的private组件。
内联方法
    定义位于类声明中的函数都将自动成为内联函数。
什么是接口？
    接口是一个共享框架，供两个系统（如用户和计算机之间）交互使使用；
    接口让程序员能够编写与类对象交互得代码


构造函数
    如果程序中没有提供任何构造函数，则编译器会为程序定义一个默认构造函数；否则，必须自己提供默认构造函数。
    
    默认构造函数
    Stock::Stock()
    {
        company = "no name";
        shares = 0;
        share_val = 0.0;
        total_val = 0.0;
    }
    
    
初始化列表
class Cstu
{
    public:
    int a;
    double f;
    Cstu() : a(12), f(12.2f)//成员的初始化顺序只与声明顺序有关，跟初始化列表的书写顺序无关
    {
    
    }
}

析构函数
    不带参数（没有重载），只有一个
    ~Stock();


常函数
    形式：void  fun() const {;}
    构造和析构 不可以是常函数
    可以使用数据成员，不能修改数据成员
	常函数的this指针是 const CStu*
    常对象只能调用常函数，不能调用普通函数
    
    
声明对象
    Stock fitst;    //calls default constructor implicitly隐式调用默认构造函数
    Stock first = Stock();  //calls it explicitly
    Stock *prelief = new Stock; //calls it implicitly
    malloc和free不会调用构造函数和析构函数
    对于没被初始化的对象，程序使用默认构造函数来创建。
  
临时对象
    结构：类型+()
    作业域：所在语句
    Stock("Nifty food", 10, 50);
    临时变量
    int(12);
    int b = int(12);//int b = 12;
    
this指针
    所有的类方法都将this指针设置为调用它的对象的地址
    对象创建时才有，不是成员
    作用域是在类内部
    
C++允许在类里声明常量，但不允许对它进行赋值
    有一种方法——使用关键字static
    static const int Months = 23;
 
 
 拷贝构造/复制构造
 	CStu(const CStu & a)
	{
		
	}
 	何时调用
	1、新建一个对象，并将其初始化为同类现有对象
		CStu a;//声明一个对象
		1、CStu a1(a);
		2、CStu a2 = a;
		3、CStu a3 = CStu(a);
		4、CStu* a4 = new CStu(a);
		赋值不会调用
			CStu s;
			CStu p;
			s = p;
	2、当程序生成对象副本时
		函数参数传递对象的值 
		void fun(CStu b)
		{
		
		}
		函数返回对象
		CStu fun()
		{
			CStu a;
			return a;
		}
	默认的复制构造函数，逐个复制非静态成员（成员的复制成为浅复制）值，复制的是成员的值
	系统默认的这个又叫浅拷贝
	存在问题：
		1指针成员释放时导致重复释放（野指针）
深拷贝
	指针成员不能直接赋值，要用内存拷贝，memcpy,strcpyd等
	#include <string.h>
 	 void *memcpy( void *to, const void *from, size_t count );
 
	功能：函数从from中复制count 个字符到to中，并返回to指针。 如果to 和 from 重叠，则函数行为不确定。

	CStu(const CSrtu & b)
	{
		memcpy(this->a, b.a, 8);
	}
解决拷贝构造所引发的，指针成员二次释放崩溃的问题的方式
	深拷贝
	传地址
	传引用(没有临时变量，就没有拷贝构造)


友元：
	1、友元函数
	2、友元类
	3、友元成员函数
	1类的友元函数是非成员函数，其访问权限与成员函数相同
 	1只有在类声明中的原型中才能使用friend关键字


运算符重载
	ostream & operator<<(ostream & os, const CStu & stu)
	{
		os << stu.a;
		return os;
	}


基类和子类
    class SubClass : public SuperClass
    {
        
    }
